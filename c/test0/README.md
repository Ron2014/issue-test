# isdigit 的参数好奇怪

简化代码如下

```c
const char *p = strfrmt;
if(isdigit((unsigned char)(*p))) p++;
```

## 标准库中 isdigit

```c
#include <ctype.h>

int isdigit(int c);
```

通常用来测试一个字符c是否表示一位十进制数的字符形式，也就是如下10个值。

'0' '1' '2' '3' '4' '5' '6' '7' '9'

注意这里每个数据的类型都是字符(char)类型，对应的ASCII码为

0x30 ~ 0x39 (0011 0000 ~ 0011 1001)

## 分析

*p 的类型是 char

(unsigned char)(*p) 就是对 char 的一个无符号数字的扩展

因为最终要转成int(4字节)，char是1字节，这个隐式转换就会扩充（填充）3个字节的内存。

我们称之为补码。补码分两种，要么3个字节每一位填0（变成000），要么填1（变成FFF），具体看两方面：

1. 这char的最高位是0还是1
2. 这个char是无符号还是有符号

/ | 最高位为0 | 最高位为1
--- | --- | ----
char | 补0 | 补1
unsigned char | 补0 | 补0

而补码为1的情况，这个int值用十进制表示，就是负数了。

所以这里的转换可能是为了防止传递一个负数给 isdigit。

那么什么时候会为负数呢？那就是可以表示为 0x80 ~ 0xFF（1000 0000 ~ 1111 1111）之间的char。

0x80 ~ 0xFF 本身都不在 0x3F ~ 0x39 这个范围，isdigit 返回 0。哪怕是将其转义成unsigned char来消除补码的影响，也还是 isdigit 返回 0。

所以，结论是，这里的 (unsigned char) 强制转换，是否多此一举了呢？